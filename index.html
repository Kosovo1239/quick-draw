<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zeichen-Ratespiel Multiplayer</title>
<style>
  body, html {
    margin:0; padding:0; height:100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: white;
    display: flex; flex-direction: column; align-items: center;
  }
  #setup {
    margin: 12px;
  }
  input, button {
    padding: 8px 14px;
    margin: 4px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
    background: #0d6efd;
    color: white;
    cursor: pointer;
  }
  input {
    width: 180px;
    color: black;
  }
  button:hover {
    background: #084ab1;
  }
  #roomIdDisplay {
    font-weight: bold;
    margin-left: 10px;
  }
  #canvas {
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 12px #0d6efd99 inset;
    cursor: crosshair;
    touch-action: none;
    margin-top: 10px;
  }
  #wordToDraw {
    font-size: 22px;
    margin: 12px 0;
    color: #0d6efd;
  }
  #timer {
    font-size: 18px;
    margin-bottom: 8px;
  }
  #guessContainer {
    margin-top: 12px;
    display: none;
    flex-direction: column;
    align-items: center;
  }
  #guessInput {
    padding: 8px;
    font-size: 16px;
    border-radius: 6px;
    border: none;
    width: 220px;
    margin-bottom: 8px;
    color: black;
  }
  #guessBtn {
    background: #0d6efd;
    border: none;
    color: white;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 6px;
  }
  #guessBtn:hover {
    background: #084ab1;
  }
  #status {
    margin-top: 10px;
    height: 24px;
  }
</style>
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>

<div id="setup">
  <button id="createBtn">Raum erstellen</button>
  <input id="roomInput" placeholder="Raum-ID eingeben" />
  <button id="joinBtn">Beitreten</button>
  <span id="roomIdDisplay">---</span>
</div>

<div id="wordToDraw"></div>
<div id="timer"></div>

<canvas id="canvas" width="600" height="400"></canvas>

<div id="guessContainer">
  <input id="guessInput" placeholder="Was ist das?" />
  <button id="guessBtn">Raten</button>
</div>

<div id="status"></div>

<script>
  const createBtn = document.getElementById('createBtn');
  const joinBtn = document.getElementById('joinBtn');
  const roomInput = document.getElementById('roomInput');
  const roomIdDisplay = document.getElementById('roomIdDisplay');
  const wordToDraw = document.getElementById('wordToDraw');
  const timerDisplay = document.getElementById('timer');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const guessContainer = document.getElementById('guessContainer');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const status = document.getElementById('status');

  let peer, conn;
  let isDrawer = false;
  let word = "";
  let timeLeft = 10;
  let timerInterval;
  let isDrawing = false;
  let lastPos = {x:0,y:0};
  let roundActive = false;

  const words = ["Haus", "Katze", "Auto", "Blume", "Baum", "Fisch", "Sonne", "Ball", "Hund", "Vogel"];

  function generateRoomId(len=6) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let str = '';
    for(let i=0; i<len; i++) {
      str += chars.charAt(Math.floor(Math.random()*chars.length));
    }
    return str;
  }

  function drawLine(x1,y1,x2,y2,color='#0d6efd',lineWidth=3){
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function sendData(data){
    if(conn && conn.open) conn.send(data);
  }

  function setupData(){
    conn.on('data', data => {
      if(data.type === 'draw'){
        const d = data.data;
        drawLine(d.x1, d.y1, d.x2, d.y2, d.color, d.lineWidth);
      }
      else if(data.type === 'word'){
        // EmpfÃ¤nger bekommt das Wort zum Malen nicht!
        if(!isDrawer){
          wordToDraw.textContent = "";
          startGuessing();
          word = data.word;  // Wichtig: Wort speichern zum vergleichen
        }
      }
      else if(data.type === 'timer'){
        timerDisplay.textContent = `Zeit: ${data.time}s`;
        if(data.time === 0){
          endRound();
        }
      }
      else if(data.type === 'guessResult'){
        status.textContent = data.correct ? "Richtig geraten! ðŸŽ‰" : "Falsch geraten, versuch's nochmal.";
      }
    });
  }

  function startTimer(){
    timeLeft = 10;
    timerDisplay.textContent = `Zeit: ${timeLeft}s`;
    timerInterval = setInterval(() => {
      timeLeft--;
      timerDisplay.textContent = `Zeit: ${timeLeft}s`;
      sendData({type:'timer', time: timeLeft});
      if(timeLeft <= 0) {
        clearInterval(timerInterval);
        endRound();
      }
    }, 1000);
  }

  function startRound(){
    roundActive = true;
    clearCanvas();
    guessContainer.style.display = 'none';
    status.textContent = "";
    if(isDrawer){
      // Zeichner bekommt Wort gezeigt
      word = words[Math.floor(Math.random()*words.length)];
      wordToDraw.textContent = `Zeichne: ${word}`;
      sendData({type:'word', word});
      startTimer();
    } else {
      wordToDraw.textContent = "";
      startGuessing();
    }
  }

  function endRound(){
    roundActive = false;
    guessContainer.style.display = 'none';
    timerDisplay.textContent = "";
    if(isDrawer){
      wordToDraw.textContent = "Zeit vorbei!";
    } else {
      wordToDraw.textContent = "Zeichnung beendet!";
    }
    // Nach 5 Sekunden neue Runde starten (ohne Gewinnmeldung, falls kein erraten)
    setTimeout(() => {
      isDrawer = !isDrawer;  // Rollen tauschen
      startRound();
    }, 5000);
  }

  function startGuessing(){
    guessContainer.style.display = 'flex';
  }

  guessBtn.onclick = () => {
    if (!roundActive) return;
    const guess = guessInput.value.trim().toLowerCase();
    guessInput.value = "";
    if(!guess) return;
    if(isDrawer) return; // Zeichner darf nicht raten

    if(guess === word.toLowerCase()){
      sendData({type:'guessResult', correct:true});
      status.textContent = "Gewonnen! NÃ¤chste Runde...";
      clearInterval(timerInterval);
      roundActive = false;

      // Runde beenden, Rollen tauschen und nach 3 Sekunden neue Runde starten
      setTimeout(() => {
        status.textContent = "";
        isDrawer = !isDrawer;
        startRound();
      }, 3000);
    } else {
      sendData({type:'guessResult', correct:false});
      status.textContent = "Falsch geraten, versuch's nochmal.";
    }
  };

  // PeerJS Verbindungen

  createBtn.onclick = () => {
    peer = new Peer(generateRoomId());
    peer.on('open', id => {
      roomIdDisplay.textContent = id;
      status.textContent = 'Raum erstellt. Warte auf Spieler...';
    });
    peer.on('connection', connection => {
      conn = connection;
      status.textContent = 'Spieler verbunden!';
      isDrawer = true; // Erster Spieler zeichnet
      setupData();
      startRound();
    });
  };

  joinBtn.onclick = () => {
    const id = roomInput.value.trim();
    if(!id) return alert('Bitte Raum-ID eingeben!');
    peer = new Peer();
    peer.on('open', () => {
      conn = peer.connect(id);
      conn.on('open', () => {
        status.textContent = 'Verbunden! Du darfst raten.';
        isDrawer = false;
        setupData();
        startRound();
      });
      conn.on('error', e => alert('Verbindungsfehler: ' + e));
    });
  };

  // Zeichnen mit Maus

  canvas.addEventListener('mousedown', e => {
    if(!isDrawer || !roundActive) return;
    isDrawing = true;
    lastPos = getMousePos(e);
  });
  canvas.addEventListener('mouseup', e => {
    if(!isDrawer) return;
    isDrawing = false;
  });
  canvas.addEventListener('mouseout', e => {
    if(!isDrawer) return;
    isDrawing = false;
  });
  canvas.addEventListener('mousemove', e => {
    if(!isDrawer || !isDrawing) return;
    const pos = getMousePos(e);
    drawLine(lastPos.x, lastPos.y, pos.x, pos.y);
    sendData({type:'draw', data: {x1:lastPos.x, y1:lastPos.y, x2:pos.x, y2:pos.y}});
    lastPos = pos;
  });

  // Touch Support

  canvas.addEventListener('touchstart', e => {
    if(!isDrawer || !roundActive) return;
    e.preventDefault();
    isDrawing = true;
    lastPos = getTouchPos(e);
  }, {passive:false});
  canvas.addEventListener('touchend', e => {
    if(!isDrawer) return;
    e.preventDefault();
    isDrawing = false;
  }, {passive:false});
  canvas.addEventListener('touchcancel', e => {
    if(!isDrawer) return;
    e.preventDefault();
    isDrawing = false;
  }, {passive:false});
  canvas.addEventListener('touchmove', e => {
    if(!isDrawer || !isDrawing) return;
    e.preventDefault();
    const pos = getTouchPos(e);
    drawLine(lastPos.x, lastPos.y, pos.x, pos.y);
    sendData({type:'draw', data: {x1:lastPos.x, y1:lastPos.y, x2:pos.x, y2:pos.y}});
    lastPos = pos;
  }, {passive:false});

  function getMousePos(e){
    const rect = canvas.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }
  function getTouchPos(e){
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    return {x: touch.clientX - rect.left, y: touch.clientY - rect.top};
  }
</script>

</body>
</html>
